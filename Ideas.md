- Maybe disassemble should accept a stream to write to instead of writing directly to stderr
- What are the tradeoffs for making `OpCode` an `enum` vs. an `enum(u8)`. How is `ArrayList(OpCode)` actually stored if `OpCode` is an `enum`?
    - I guess we need the bytecode buffer to store data like indexes into the constants array in addition to opcodes. Forces us to say the underlying datatype of the enum.
- Is there an advantage to storing operands as later bytes, instead of making the opcodes a richer data structure?
- How do we find out if we forgot to deinitialize something in deinit?
- Use slices for many places the book uses pointers, e.g. for the scanner state and for lexemes
- Do identifierType switch with comptime
- Represent compile and interpreter errors using Zig's error system
- Note, skipping parse "rules" in favor of separate switches for precedence and unary/binary parsing. Slightly more verbose, but simpler.
- Maybe move getPrecedence to a different file?
- Writing "try" a lot. Are there any suggested style improvements?
- [x] Move "verbose" flags into a "flags" or "debug" file.
- Instead of returning null from peek in scanner, be more careful about checking if we're at the end?
- Zig's way of switching on unions and constructing union members is way nicer than the macros in C in the book
- Can we cut down on boilerplate in VM's Add/Subtract/Multiply/Divide routines?
- Fix printing of float values
- Who "owns" the memory that holds string values created by the parser? Seems natural for the VM to own this memory, since it will also be responsible for owning memory created at runtime.
- Currently using ?*Obj for "next" pointer in objects. Could probably save space by representing the end of the list with a pointer that points back to the current object instead of using an optional here.
- Interesting that lox chooses not to implement any escapes in strings
- How should we handle OutOfMemory?
- Could make our hash table generic for not much more effort. But could also just use the standard library hash map, which is already generic.
- Why doesn't hash table get function just return the value it finds?
- Would probably be more efficient to use Zig's standard library hash map to implement string interning, since there is only one possible value, and Zig knows how to optimize that case.
- Choosing not to implement copyString for now--it's really a performance optimization on top of takeString. May benchmark at the "optimization" phase to decide if this is worth it.
- Using *ObjString as the key for our hash table is a little tricky. You have to put an ObjString inside an Obj to get a valid pointer, but an Obj can also hold other kinds of data. Initially got tripped up by passing a pointer to a local variable bound to an ObjString.
- Allow repl line length to be longer than 256
