- Maybe disassemble should accept a stream to write to instead of writing directly to stderr
- What are the tradeoffs for making `OpCode` an `enum` vs. an `enum(u8)`. How is `ArrayList(OpCode)` actually stored if `OpCode` is an `enum`?
    - I guess we need the bytecode buffer to store data like indexes into the constants array in addition to opcodes. Forces us to say the underlying datatype of the enum.
- Is there an advantage to storing operands as later bytes, instead of making the opcodes a richer data structure?
- How do we find out if we forgot to deinitialize something in deinit?
- Use slices for many places the book uses pointers, e.g. for the scanner state and for lexemes
- Do identifierType switch with comptime
- Represent compile and interpreter errors using Zig's error system
- Note, skipping parse "rules" in favor of separate switches for precedence and unary/binary parsing. Slightly more verbose, but simpler.
- Maybe move getPrecedence to a different file?
- Writing "try" a lot. Are there any suggested style improvements?
- [x] Move "verbose" flags into a "flags" or "debug" file.
- Instead of returning null from peek in scanner, be more careful about checking if we're at the end?
- Zig's way of switching on unions and constructing union members is way nicer than the macros in C in the book
- Can we cut down on boilerplate in VM's Add/Subtract/Multiply/Divide routines?
- Fix printing of float values
- Who "owns" the memory that holds string values created by the parser? Seems natural for the VM to own this memory, since it will also be responsible for owning memory created at runtime.
- Currently using ?*Obj for "next" pointer in objects. Could probably save space by representing the end of the list with a pointer that points back to the current object instead of using an optional here.
- Interesting that lox chooses not to implement any escapes in strings
- How should we handle OutOfMemory?